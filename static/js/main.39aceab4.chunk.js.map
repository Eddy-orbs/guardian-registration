{"version":3,"sources":["logo.svg","serviceWorker.ts","App.tsx","store/CryptoWalletConnectionStore.ts","store/OrbsAccountStore.ts","services/cryptoWalletConnectionService/CryptoWalletConnectionService.ts","configs.ts","services/OrbsClientFactory.ts","theme/Theme.tsx","store/storesInitialization.ts","AppWrapper.tsx","services/Services.ts","index.tsx"],"names":["module","exports","Boolean","window","location","hostname","match","App","className","src","logo","alt","href","target","rel","CryptoWalletConnectionStore","action","cryptoWalletConnectionService","addressCheckingInterval","undefined","reactionToWalletConnection","this","hasEthereumProvider","hasEventsSupport","reaction","isConnectedToWallet","isConnected","a","readInformationFromConnectedWallet","fireImmediately","onMainAddressChange","address","setMainAddress","readMainAddress","then","setInterval","requestConnectionPermission","permissionGranted","setWalletConnectionRequestApproved","walletConnectionRequestApproved","walletAddress","requestApproved","mainAddress","didUserApproveDappInThePast","observable","computed","OrbsAccountStore","cryptoWalletIntegrationStore","guardiansService","addressChangeReaction","setDoneLoading","reactToConnectedAddressChanged","currentAddress","setDefaultAccountAddress","refreshAccountListeners","readDataForAccount","failLoadingProcess","console","error","accountAddress","cancelAllCurrentSubscriptions","setErrorLoading","doneLoading","errorLoading","CryptoWalletConnectionService","ethereum","web3","isMetamaskInstalled","isSemiCompliantEthereumProviderInstalled","isMetaMask","Web3","onFunction","on","enable","networkVersion","eth","getAccounts","accounts","getBlockNumber","onChange","Error","listener","off","selectedAddress","INFURA_KEY","process","ETHEREUM_NETWORK","REACT_APP_INFURA_KEY","configs","urlBase","PUBLIC_BASE_PATH","ETHEREUM_PROVIDER_WS","log","config","ORBS_NODE_URL","toString","baseTheme","responsiveFontSizes","createMuiTheme","palette","type","primary","main","secondary","text","background","default","typography","overrides","MuiPaper","root","backgroundColor","MuiTypography","colorPrimary","color","MuiLink","blue","configure","enforceActions","services","ethereumProvider","orbsClient","createAccount","publicKey","privateKey","signer","LocalSigner","Client","NetworkType","NETWORK_TYPE_TEST_NET","BuildOrbsClient","orbsClientService","OrbsClientService","providers","WebsocketProvider","cryptoWalletIntegrationService","GuardiansService","buildServices","stores","orbsAccountStore","getStores","AppWrapper","React","memo","props","StylesProvider","injectFirst","ThemeProvider","theme","CssBaseline","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.39aceab4.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          Edit <code>src/App.tsx</code> and save to reload.\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n        </a>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import { action, computed, observable, reaction } from \"mobx\";\nimport { ICryptoWalletConnectionService } from \"../services/cryptoWalletConnectionService/ICryptoWalletConnectionService\";\nimport { IReactionDisposer } from \"mobx/lib/core/reaction\";\n\nexport class CryptoWalletConnectionStore {\n  @observable private walletConnectionRequestApproved: boolean = false;\n\n  @observable public hasEthereumProvider: boolean;\n  @observable public hasEventsSupport: boolean;\n\n  @observable public mainAddress: string = \"\";\n\n  private addressCheckingInterval?: NodeJS.Timeout = undefined;\n  reactionToWalletConnection: IReactionDisposer;\n\n  constructor(\n    private cryptoWalletConnectionService: ICryptoWalletConnectionService\n  ) {\n    this.hasEthereumProvider =\n      cryptoWalletConnectionService.hasEthereumProvider;\n    this.hasEventsSupport = cryptoWalletConnectionService.hasEventsSupport;\n\n    this.reactionToWalletConnection = reaction(\n      () => this.isConnectedToWallet,\n      async (isConnected) => {\n        if (isConnected) {\n          this.readInformationFromConnectedWallet();\n        }\n      },\n      {\n        fireImmediately: true,\n      }\n    );\n\n    if (this.hasEthereumProvider) {\n      // We will only detect address change if the Ethereum provider can support it\n      if (this.cryptoWalletConnectionService.hasEventsSupport) {\n        this.cryptoWalletConnectionService.onMainAddressChange((address) =>\n          this.setMainAddress(address)\n        );\n      } else {\n        // Else, we will read it one time + set an interval\n        this.cryptoWalletConnectionService\n          .readMainAddress()\n          .then((address) => this.setMainAddress(address));\n\n        this.addressCheckingInterval = setInterval(\n          () =>\n            this.cryptoWalletConnectionService\n              .readMainAddress()\n              .then((address) => this.setMainAddress(address)),\n          1000\n        );\n      }\n    }\n  }\n\n  @computed\n  public get isConnectedToWallet(): boolean {\n    return (\n      this.hasEthereumProvider &&\n      (this.cryptoWalletConnectionService.didUserApproveDappInThePast ||\n        this.walletConnectionRequestApproved)\n    );\n  }\n\n  public async askToConnect(): Promise<boolean> {\n    if (this.isConnectedToWallet) {\n      return true;\n    } else {\n      const permissionGranted = await this.cryptoWalletConnectionService.requestConnectionPermission();\n      this.setWalletConnectionRequestApproved(permissionGranted);\n\n      return this.walletConnectionRequestApproved;\n    }\n  }\n\n  private async readInformationFromConnectedWallet() {\n    const walletAddress = await this.cryptoWalletConnectionService.readMainAddress();\n\n    this.setMainAddress(walletAddress);\n  }\n\n  @action(\"setWalletConnectionRequestApproved\")\n  private setWalletConnectionRequestApproved(requestApproved: boolean) {\n    this.walletConnectionRequestApproved = requestApproved;\n  }\n\n  @action(\"setMainAddress\")\n  private setMainAddress(mainAddress: string) {\n    this.mainAddress = mainAddress;\n  }\n}\n","import {\n  action,\n  computed,\n  IReactionDisposer,\n  observable,\n  reaction,\n} from \"mobx\";\nimport { IGuardiansService } from \"orbs-pos-data\";\nimport { CryptoWalletConnectionStore } from \"./CryptoWalletConnectionStore\";\nexport class OrbsAccountStore {\n  @observable public doneLoading = false;\n  @observable public errorLoading = false;\n\n  @computed get isGuardian(): boolean {\n    return true;\n  }\n\n  private addressChangeReaction: IReactionDisposer;\n\n  constructor(\n    private cryptoWalletIntegrationStore: CryptoWalletConnectionStore,\n    private guardiansService: IGuardiansService\n  ) {\n    this.addressChangeReaction = reaction(\n      () => this.cryptoWalletIntegrationStore.mainAddress,\n      async (address) => {\n        this.setDoneLoading(false);\n        await this.reactToConnectedAddressChanged(address);\n        this.setDoneLoading(true);\n      },\n      {\n        fireImmediately: true,\n      }\n    );\n  }\n\n  // **** Contract interactions ****\n\n  // **** Current address changed ****\n\n  private async reactToConnectedAddressChanged(currentAddress: string) {\n    if (currentAddress) {\n      this.setDefaultAccountAddress(currentAddress);\n\n      if (this.cryptoWalletIntegrationStore.hasEventsSupport) {\n        this.refreshAccountListeners(currentAddress);\n      }\n\n      try {\n        await this.readDataForAccount(currentAddress);\n      } catch (e) {\n        this.failLoadingProcess(e);\n        console.error(\n          \"Error in reacting to address change in Orbs Account Store\",\n          e\n        );\n      }\n    }\n  }\n\n  private setDefaultAccountAddress(accountAddress: string) {\n    // this.stakingService.setFromAccount(accountAddress);\n    // this.orbsTokenService.setFromAccount(accountAddress);\n  }\n\n  // **** Data reading and setting ****\n\n  public async manuallyReadAccountData() {\n    try {\n      await this.readDataForAccount(\n        this.cryptoWalletIntegrationStore.mainAddress\n      );\n    } catch (e) {\n      this.failLoadingProcess(e);\n      console.error(\n        \"Error in manually reading address data in Orbs Account Store\",\n        e\n      );\n    }\n  }\n\n  private async readDataForAccount(accountAddress: string) {}\n\n  // ****  Subscriptions ****\n\n  private async refreshAccountListeners(accountAddress: string) {\n    this.cancelAllCurrentSubscriptions();\n  }\n\n  private cancelAllCurrentSubscriptions() {}\n\n  // ****  Complex setters ****\n  private failLoadingProcess(error: Error) {\n    this.setErrorLoading(true);\n    this.setDoneLoading(true);\n  }\n\n  // ****  Observables setter actions ****\n  @action(\"setDoneLoading\")\n  private setDoneLoading(doneLoading: boolean) {\n    this.doneLoading = doneLoading;\n  }\n\n  @action(\"setErrorLoading\")\n  private setErrorLoading(errorLoading: boolean) {\n    this.errorLoading = errorLoading;\n  }\n}\n","import Web3 from \"web3\";\nimport { ICryptoWalletConnectionService } from \"./ICryptoWalletConnectionService\";\nimport { IEthereumProvider } from \"./IEthereumProvider\";\n\n// TODO : FUTURE : O.L : IMPORTANT : Get this service and all other common services into a package\n//        To be used by all web-products.\n// TODO : FUTURE : O.L : Change all ethereum.<call> to the new standard events format.\nexport class CryptoWalletConnectionService\n  implements ICryptoWalletConnectionService {\n  private readonly web3?: Web3;\n  public readonly hasEthereumProvider: boolean;\n  public readonly hasEventsSupport: boolean;\n  public readonly isMetamaskInstalled: boolean;\n  public readonly isSemiCompliantEthereumProviderInstalled: boolean;\n\n  constructor(private ethereum: IEthereumProvider) {\n    this.hasEthereumProvider = this.ethereum !== undefined;\n\n    // Distinguishes between installed ethereum providers\n    this.isMetamaskInstalled =\n      this.hasEthereumProvider && !!this.ethereum.isMetaMask;\n    this.isSemiCompliantEthereumProviderInstalled =\n      this.hasEthereumProvider && !this.ethereum.isMetaMask;\n\n    if (this.hasEthereumProvider) {\n      this.web3 = new Web3(this.ethereum as any);\n    }\n\n    const onFunction = this.hasEthereumProvider ? this.ethereum.on : undefined;\n    this.hasEventsSupport = onFunction !== undefined && onFunction !== null;\n  }\n\n  public async requestConnectionPermission(): Promise<boolean> {\n    try {\n      await this.ethereum.enable();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Getters\n  public get didUserApproveDappInThePast(): boolean {\n    // DEV_NOTE : O.L : IMPORTANT ! : This currently works with the soon to be deprecated apis of metamask injected 'ethereum'\n    //                                and is not part of the properties in the official types of web3.\n    //                                We need to check and find a better way to detect if the user has already approved wallet access.\n    // @ts-ignore\n    return this.isMetamaskInstalled && !!this.ethereum.selectedAddress;\n  }\n\n  async getIsMainNetwork(): Promise<boolean> {\n    return this.isMetamaskInstalled && this.ethereum.networkVersion === \"1\";\n  }\n\n  // Data \"reading\"\n  async readMainAddress(): Promise<string> {\n    const accounts = (await this.web3?.eth.getAccounts()) || [];\n    return accounts[0];\n  }\n\n  async readCurrentBlockNumber(): Promise<number> {\n    return this.web3?.eth.getBlockNumber() || 0;\n  }\n\n  // Event listeners\n  onMainAddressChange(onChange: (mainAddress: string) => void): () => void {\n    if (!this.hasEventsSupport) {\n      throw new Error(\n        `Cannot subscribe to events with given Ethereum provider`\n      );\n    }\n\n    const listener = (accounts: string[]) => onChange(accounts[0]);\n\n    this.ethereum.on(\"accountsChanged\", listener);\n\n    return () => {\n      this.ethereum.off(\"accountsChanged\", listener);\n    };\n  }\n}\n","import { IOrbsPosContractsAddresses } from \"orbs-pos-data\";\n\n/**\n * Copyright 2019 the prism authors\n * This file is part of the prism library in the Orbs project.\n *\n * This source code is licensed under the MIT license found in the LICENSE file in the root directory of this source tree.\n * The above notice should be included in all copies or substantial portions of the software.\n */\n\ntype TSupportedNets = \"local\" | \"ropsten\" | \"mainnet\";\n// @ts-ignore\nconst ethereumNetwork: TSupportedNets = process.env.ETHEREUM_NETWORK;\n\nconst INFURA_KEY = process.env.REACT_APP_INFURA_KEY;\n\nexport const IS_DEV = process.env.NODE_ENV !== \"production\";\nconst SHOULD_OVERRIDE_ADDRESS = IS_DEV || ethereumNetwork === \"ropsten\";\n\n////////////// CONFIG VARIABLES ///////////////\ninterface IConfig {\n  urlBase: string;\n  ETHEREUM_PROVIDER_WS: string;\n}\n\nconst configs: IConfig = {\n  urlBase: process.env.PUBLIC_BASE_PATH || \"\",\n  ETHEREUM_PROVIDER_WS: `wss://mainnet.infura.io/ws/v3/${INFURA_KEY}`,\n};\n\nconsole.log({ config: configs });\n\n// Webpack will remove this section on production build //\nif (process.env.NODE_ENV !== \"production\") {\n  // TODO : ORL : Add here dev addresses\n}\n\nexport default configs;\n","import { Client, createAccount, NetworkType } from \"orbs-client-sdk\";\nimport { LocalSigner } from \"orbs-client-sdk\";\n\n// TODO : IMPORTANT : O.L : This file is a duplicate from 'staking wallet', extract it to a common code.\n\nconst ORBS_VIRTUAL_CHAIN_ID = 1_100_000; // The virtual chain Id on the Orbs network\nconst ORBS_NODE_ADDRESS = \"validator.orbs.com\"; // The Orbs node that we will query\nconst PROTOCOL = \"https\";\nconst ORBS_NODE_URL = `${PROTOCOL}://${ORBS_NODE_ADDRESS}/vchains/${ORBS_VIRTUAL_CHAIN_ID.toString()}`;\n\nexport function BuildOrbsClient(): Client {\n  const { publicKey, privateKey } = createAccount();\n  const signer = new LocalSigner({ publicKey, privateKey });\n  return new Client(\n    ORBS_NODE_URL,\n    ORBS_VIRTUAL_CHAIN_ID,\n    NetworkType.NETWORK_TYPE_TEST_NET,\n    signer\n  );\n}\n","import { blue } from \"@material-ui/core/colors\";\nimport responsiveFontSizes from \"@material-ui/core/styles/responsiveFontSizes\";\nimport createMuiTheme from \"@material-ui/core/styles/createMuiTheme\";\n\nconst COLOR1 = \"#0D0D0D\"; // dark gray\nconst COLOR2 = \"#6ec6d8\"; // bluish\nconst COLOR3 = \"#03FCF5\"; // bright bluish- Tetra\n\n// const PRIMARY_TEXT = '#dbdbdb';\nconst PRIMARY_TEXT = \"#dbdbdb\";\nconst SECONDARY_TEXT = \"#7B7B7B\";\n\nexport const baseTheme = responsiveFontSizes(\n  createMuiTheme({\n    palette: {\n      type: \"dark\",\n      primary: {\n        main: COLOR1,\n      },\n      secondary: {\n        main: COLOR3,\n      },\n      text: {\n        primary: PRIMARY_TEXT,\n        secondary: SECONDARY_TEXT,\n      },\n      background: {\n        // DEV_NOTE : This sets the app background color\n        default: \"#121212\",\n      },\n    },\n    typography: {\n      // fontFamily: 'Montserrat',\n    },\n    overrides: {\n      MuiPaper: {\n        root: {\n          backgroundColor: COLOR1,\n        },\n      },\n      MuiTypography: {\n        colorPrimary: {\n          color: PRIMARY_TEXT,\n        },\n      },\n      MuiLink: {\n        root: {\n          color: blue[500],\n        },\n      },\n    },\n  })\n);\n\nexport const AppStyles = {};\n","import { configure } from \"mobx\";\nimport { IStores } from \"./stores\";\nimport {\n  IOrbsPOSDataService,\n  IStakingService,\n  IOrbsTokenService,\n  IGuardiansService,\n  IOrbsRewardsService,\n} from \"orbs-pos-data\";\n\nimport { CryptoWalletConnectionStore } from \"./CryptoWalletConnectionStore\";\nimport { ICryptoWalletConnectionService } from \"../services/cryptoWalletConnectionService/ICryptoWalletConnectionService\";\nimport { OrbsAccountStore } from \"./OrbsAccountStore\";\n\n/**\n * Configures the mobx library. Should get called at App's initialization.\n */\nexport function configureMobx() {\n  configure({\n    enforceActions: \"observed\",\n  });\n}\n\n/**\n * Builds and initializes all of the stores\n */\nexport function getStores(\n  cryptoWalletConnectionService: ICryptoWalletConnectionService,\n  guardiansService: IGuardiansService\n): IStores {\n  // Create stores instances + Hydrate the stores\n  const cryptoWalletIntegrationStore = new CryptoWalletConnectionStore(\n    cryptoWalletConnectionService\n  );\n  const orbsAccountStore = new OrbsAccountStore(\n    cryptoWalletIntegrationStore,\n    guardiansService\n  );\n\n  const stores: IStores = {\n    cryptoWalletIntegrationStore,\n    orbsAccountStore,\n  };\n\n  return stores;\n}\n","import React from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport { Provider } from \"mobx-react\";\nimport App from \"./App\";\nimport { configureMobx, getStores } from \"./store/storesInitialization\";\nimport { buildServices } from \"./services/Services\";\nimport { StylesProvider, ThemeProvider } from \"@material-ui/core/styles\";\nimport { AppStyles, baseTheme } from \"./theme/Theme\";\nimport { CssBaseline } from \"@material-ui/core\";\ninterface IProps {}\n\nconfigureMobx();\n\nconst ethereumProvider = (window as any).ethereum;\nconst services = buildServices(ethereumProvider);\nconst stores = getStores(\n  services.cryptoWalletIntegrationService,\n  services.guardiansService\n);\n\nexport const AppWrapper = React.memo<IProps>((props) => {\n  return (\n    <Router>\n      <Provider {...stores} {...services}>\n        <StylesProvider injectFirst>\n          <ThemeProvider theme={baseTheme}>\n            <App />\n            <CssBaseline />\n          </ThemeProvider>\n        </StylesProvider>\n      </Provider>\n    </Router>\n  );\n});\n","import { IEthereumProvider } from \"./cryptoWalletConnectionService/IEthereumProvider\";\nimport { CryptoWalletConnectionService } from \"./cryptoWalletConnectionService/CryptoWalletConnectionService\";\nimport { ICryptoWalletConnectionService } from \"./cryptoWalletConnectionService/ICryptoWalletConnectionService\";\nimport {\n  GuardiansService,\n  IGuardiansService,\n  IOrbsClientService,\n  OrbsClientService,\n} from \"orbs-pos-data\";\nimport Web3 from \"web3\";\nimport configs from \"../configs\";\nimport { BuildOrbsClient } from \"./OrbsClientFactory\";\n\nexport interface IServices {\n  cryptoWalletIntegrationService: ICryptoWalletConnectionService;\n  guardiansService: IGuardiansService;\n}\n\n// DEV_NOTE : For simplicity of early stage dev, we assume that we have ethereum provider, if not, we will not initialize the services.\nexport function buildServices(ethereumProvider: IEthereumProvider): IServices {\n  let web3: Web3;\n\n  const orbsClient = BuildOrbsClient();\n  const orbsClientService: IOrbsClientService = new OrbsClientService(\n    orbsClient\n  );\n\n  if (ethereumProvider) {\n    web3 = new Web3(ethereumProvider as any);\n  } else {\n    web3 = new Web3(\n      new Web3.providers.WebsocketProvider(configs.ETHEREUM_PROVIDER_WS)\n    );\n  }\n\n  return {\n    cryptoWalletIntegrationService: new CryptoWalletConnectionService(\n      ethereumProvider\n    ),\n    guardiansService: new GuardiansService(web3, orbsClientService),\n  };\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport {AppWrapper} from \"./AppWrapper\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <AppWrapper />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}